<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>LoaderTest</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>

    <script type="module">
        //THE url for viewing this file 8080 or 8081 or etc. 
        //http://10.8.8.27:8081/WebXRAssest/Code/03.OneSceneTest.html    

        //import * as THREE from './HELLO-WORLD/WebXRAssest/FirstThree/build/three.module.js';
        import * as THREE from '../../WebXRAssest/build/three.module.js';
        import Stats from '../../WebXRAssest/jsm/libs/stats.module.js';
        import { GLTFLoader } from '../../WebXRAssest/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from '../../WebXRAssest/jsm/controls/OrbitControls.js';
        //import {FirstPersonControls} from '../../WebXRAssest/jsm/controls/FirstPersonControls.js';

        //create stats monitor the performance
        const stats = new Stats();
        document.body.appendChild(stats.dom);

        //create scene, camera, renderer and clock
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f0f0f);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 100);
        camera.position.z = 3;
        camera.position.y = 1.6;
        camera.lookAt(0, 40, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        //const clock = new THREE.Clock();
        //This sRGBEncoding don't take light?
        //renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        //OrbitControls 
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.6, 0);
        controls.minDistance = 0.15;
        controls.maxDistance = 100;
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.4;

        //FirstPerson controls
        // const controls = new FirstPersonControls( camera, renderer.domElement );
		// controls.movementSpeed = 15;
		// controls.lookSpeed = 0.2;



        //cube
        const cubeSize = 1;
        const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        const cubeMat = new THREE.MeshPhongMaterial({ color: '#8AC' });
        const mesh = new THREE.Mesh(cubeGeo, cubeMat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.position.set(-1, 2, 1);
        scene.add(mesh);



        //gltf loader scene
        const loader = new GLTFLoader();
        loader.load(
            '../../WebXRAssest/model/CyberCar.glb',
            function (gltf) {
                const model = gltf.scene;
                //model.scale.set(0.1, 0.1, 0.1);
                model.position.set(0, 0, 0);

                gltf.scene.traverse(
                    function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    }
                );

                scene.add(gltf.scene);

            },
            undefined,
            function (error) {
                console.error("Scene had some problem");
            }
        );

        //Lamp
        const loader1024 = new GLTFLoader();
        loader1024.load(
            '../../WebXRAssest/model/lamp1024.glb',
            function (gltf) {
                const model = gltf.scene;
                model.scale.set(0.1, 0.1, 0.1);
                model.position.set(0, 0, -5);

                gltf.scene.traverse(
                    function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    }
                );
                scene.add(gltf.scene);

            }, undefined, function (error) {
                console.error("Lamp had some problem");
            }
        );


        //light HemisphereLight and helper
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        hemiLight.position.set(0, 10, 0);
        scene.add(hemiLight);

        const hemiLightHelper = new THREE.HemisphereLightHelper(hemiLight, 0.5);
        scene.add(hemiLightHelper);


        //light DirectionalLight and helper
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.castShadow = true;
        dirLight.color.setHSL(0.1, 1, 0.95);
        dirLight.position.set(- 1, 1.75, 1);
        dirLight.position.multiplyScalar(8);
        scene.add(dirLight);
        scene.add(dirLight.target);

        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;

        const d = 20;
        dirLight.shadow.camera.left = - d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = - d;
        dirLight.shadow.camera.far = 1000;
        dirLight.shadow.bias = - 0.0001;

        const cameraHelper = new THREE.CameraHelper(dirLight.shadow.camera);
        scene.add(cameraHelper);
        const dirLightHelper = new THREE.DirectionalLightHelper(dirLight, 10);
        scene.add(dirLightHelper);




        //anime & render
        function animate() {
            stats.begin();

            render();

            stats.end();
        };

        renderer.setAnimationLoop(animate);

        //render
        function render() {
            //first person controls update
            //controls.update( clock.getDelta() );

            const r = Date.now() * 0.0005;
            mesh.position.x = 2 * Math.cos(r);
            mesh.position.z = 2 * Math.sin(r);


            //Orbital enable damping is true
            controls.update();

            renderer.render(scene, camera);
        }

        //windows resize
        window.addEventListener("resize", onWindowResize);

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            //HandleResize function from flycontroller
            //controls.handleResize();
        }

    </script>
</body>

</html>